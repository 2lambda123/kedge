package discovery

import (
	"context"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"time"

	pb_config "github.com/mwitkow/kedge/_protogen/kedge/config"
	pb_resolvers "github.com/mwitkow/kedge/_protogen/kedge/config/common/resolvers"
	pb_grpcbackends "github.com/mwitkow/kedge/_protogen/kedge/config/grpc/backends"
	pb_grpcroutes "github.com/mwitkow/kedge/_protogen/kedge/config/grpc/routes"
	pb_httpbackends "github.com/mwitkow/kedge/_protogen/kedge/config/http/backends"
	pb_httproutes "github.com/mwitkow/kedge/_protogen/kedge/config/http/routes"
	"github.com/mwitkow/kedge/lib/k8s"
	"github.com/mwitkow/kedge/lib/sharedflags"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
)

var (
	flagExternalDomainSuffix = sharedflags.Set.String("discovery_external_domain_suffix", "", "Required suffix "+
		"that will be added to service name to constructs external domain for director route")
	flagLabelSelector = sharedflags.Set.String("discovery_service_selector", "kedge-exposed",
		"Expected label on kubernetes service to be present if service wants to be exposed by kedge."+
			"Kedge will use this label as selector for value 'true'")
	flagHTTPAnnotationPrefix = sharedflags.Set.String("discovery_service_http_annotation_prefix", "http.exposed.kedge.com/",
		"Expected annotation prefix for kubernetes service to be present if service wants to expose HTTP port by kedge."+
			"Kedge will use this annotation as director route -> backend pair. Value of this URL must be host_matcher:port_matcher.")
	flagGRPCAnnotationPrefix = sharedflags.Set.String("discovery_service_grpc_annotation_prefix", "grpc.exposed.kedge.com/",
		"Expected annotation prefix for kubernetes service to be present if service wants to expose GRPC port by kedge."+
			"Kedge will use this annotation as director route -> backend pair. Value of this must be service_name_matcher:port_matcher.")
)

// Routing Discovery allows to get fresh director and backendpool configuration filled with autogenerated routings based on service annotations.
// It watches every services (from whatever namespace) that have label name defined in 'discovery_service_selector'.
// It checks every service for annotation with prefix defined in 'discovery_service_http_annotation_prefix' (for HTTP)
// and 'discovery_service_grpc_annotation_prefix' (for gRPC) flags and generates routing->backend pair
// based on port given in the annotation.
// NOTE current limitations:
// - no check for duplicated host_matchers in annotations or between autogenerated & base ones (!)
// - no check if the target port inside service actually exists.
type RoutingDiscovery struct {
	logger               logrus.FieldLogger
	serviceClient        ServiceClient
	baseBackendpool      *pb_config.BackendPoolConfig
	baseDirector         *pb_config.DirectorConfig
	labelSelectorKey     string
	externalDomainSuffix string
	httpAnnotationPrefix string
	grpcAnnotationPrefix string
}

func NewFromFlags(logger logrus.FieldLogger, baseDirector *pb_config.DirectorConfig, baseBackendpool *pb_config.BackendPoolConfig) (*RoutingDiscovery, error) {
	if *flagExternalDomainSuffix == "" {
		return nil, errors.Errorf("required flag 'discovery_external_domain_suffix' is not specified.")
	}

	apiClient, err := k8s.NewFromFlags()
	if err != nil {
		return nil, err
	}
	return NewWithClient(logger, baseDirector, baseBackendpool, &client{k8sClient: apiClient}), nil
}

// NewWithClient returns a new Kubernetes RoutingDiscovery using given k8s.APIClient configured to be used against kube-apiserver.
func NewWithClient(logger logrus.FieldLogger, baseDirector *pb_config.DirectorConfig, baseBackendpool *pb_config.BackendPoolConfig, serviceClient ServiceClient) *RoutingDiscovery {
	return &RoutingDiscovery{
		logger:               logger,
		baseBackendpool:      baseBackendpool,
		baseDirector:         baseDirector,
		serviceClient:        serviceClient,
		labelSelectorKey:     *flagLabelSelector,
		externalDomainSuffix: *flagExternalDomainSuffix,
		httpAnnotationPrefix: *flagHTTPAnnotationPrefix,
		grpcAnnotationPrefix: *flagGRPCAnnotationPrefix,
	}
}

// DiscoverOnce returns director & backendpool configs filled with mix of persistent routes & backends given in base configs and dynamically discovered ones.
func (d *RoutingDiscovery) DiscoverOnce(ctx context.Context) (*pb_config.DirectorConfig, *pb_config.BackendPoolConfig, error) {
	ctx, cancel := context.WithTimeout(ctx, 4*time.Second) // Let's give 4 seconds to gather all changes.
	defer cancel()

	watchResultCh := make(chan watchResult)
	defer close(watchResultCh)

	err := startWatchingServicesChanges(ctx, d.labelSelectorKey, d.serviceClient, watchResultCh)
	if err != nil {
		return nil, nil, errors.Wrapf(err, "Failed to start watching services by %s selector stream", d.labelSelectorKey)
	}

	updater := newUpdater(
		d.baseDirector,
		d.baseBackendpool,
		d.externalDomainSuffix,
		d.httpAnnotationPrefix,
		d.grpcAnnotationPrefix,
	)

	var resultDirectorConfig *pb_config.DirectorConfig
	var resultBackendPool *pb_config.BackendPoolConfig
	for {
		var event event
		select {
		case <-ctx.Done():
			// Time is up, let's return what we have so far.
			return resultDirectorConfig, resultBackendPool, nil
		case r := <-watchResultCh:
			if r.err != nil {
				return nil, nil, errors.Wrap(r.err, "error on reading event stream")
			}
			event = *r.ep
		}

		resultDirectorConfig, resultBackendPool, err = updater.onEvent(event)
		if err != nil {
			return nil, nil, errors.Wrapf(err, "error on updating routing on event %v", event)
		}
	}
}

type httpRoute struct {
	hostMatcher string
	portMatcher uint32
	domainPort  string
}

type grpcRoute struct {
	serviceNameMatcher string
	portMatcher        uint32
	domainPort         string
}

type serviceKey struct {
	name, namespace string
}

type serviceRoutings struct {
	// by backend name.
	http map[string]httpRoute
	grpc map[string]grpcRoute
}

type updater struct {
	currentDirectorConfig *pb_config.DirectorConfig
	currentBackendConfig  *pb_config.BackendPoolConfig
	externalDomainSuffix  string
	httpAnnotationPrefix  string
	grpcAnnotationPrefix  string

	lastSeenServices map[serviceKey]serviceRoutings
}

func newUpdater(
	baseDirector *pb_config.DirectorConfig,
	baseBackendpool *pb_config.BackendPoolConfig,
	externalDomainSuffix string,
	httpAnnotationPrefix string,
	grpcAnnotationPrefix string,
) *updater {
	resultDirectorConfig := &pb_config.DirectorConfig{
		Grpc: &pb_config.DirectorConfig_Grpc{},
		Http: &pb_config.DirectorConfig_Http{},
	}
	resultBackendPool := &pb_config.BackendPoolConfig{
		Grpc:             &pb_config.BackendPoolConfig_Grpc{},
		Http:             &pb_config.BackendPoolConfig_Http{},
		TlsServerConfigs: baseBackendpool.TlsServerConfigs,
	}

	// Copy base for HTTP.
	if baseDirector.GetHttp() != nil {
		for _, route := range baseDirector.GetHttp().GetRoutes() {
			resultDirectorConfig.GetHttp().Routes = append(resultDirectorConfig.GetHttp().Routes, route)
		}

		for _, route := range baseDirector.GetHttp().GetAdhocRules() {
			resultDirectorConfig.GetHttp().AdhocRules = append(resultDirectorConfig.GetHttp().AdhocRules, route)
		}
	}
	if baseBackendpool.GetHttp() != nil {
		for _, backend := range baseBackendpool.GetHttp().GetBackends() {
			resultBackendPool.GetHttp().Backends = append(resultBackendPool.GetHttp().Backends, backend)
		}
	}

	// Copy base for gRPC.
	if baseDirector.GetGrpc() != nil {
		for _, route := range baseDirector.GetGrpc().GetRoutes() {
			resultDirectorConfig.GetGrpc().Routes = append(resultDirectorConfig.GetGrpc().Routes, route)
		}
	}
	if baseBackendpool.GetGrpc() != nil {
		for _, backend := range baseBackendpool.GetGrpc().GetBackends() {
			resultBackendPool.GetGrpc().Backends = append(resultBackendPool.GetGrpc().Backends, backend)
		}
	}

	return &updater{
		currentDirectorConfig: resultDirectorConfig,
		currentBackendConfig:  resultBackendPool,
		externalDomainSuffix:  externalDomainSuffix,
		httpAnnotationPrefix:  httpAnnotationPrefix,
		grpcAnnotationPrefix:  grpcAnnotationPrefix,
		lastSeenServices:      make(map[serviceKey]serviceRoutings),
	}
}

func (u *updater) onEvent(e event) (*pb_config.DirectorConfig, *pb_config.BackendPoolConfig, error) {
	service := e.Object
	name := service.Metadata.Name
	namespace := service.Metadata.Namespace

	key := serviceKey{name, namespace}

	routings, ok := u.lastSeenServices[key]
	if ok {
		if e.Type == added {
			return nil, nil, errors.Errorf("Got Added event for item %v that already exists", key)
		}
	} else {
		if e.Type == modified || e.Type == deleted {
			return nil, nil, errors.Errorf("Got %s event for item %v that we are seeing for the first time", e.Type, key)
		}
		routings = serviceRoutings{
			http: make(map[string]httpRoute),
			grpc: make(map[string]grpcRoute),
		}
	}

	if service.Metadata.Annotations == nil || e.Type == deleted {
		for backendName, r := range routings.http {
			u.applyHTTPRouteToDirectorAndBackendpool(backendName, httpRoute{}, r, e.Type)
		}

		for backendName, r := range routings.grpc {
			u.applygRPCRouteToDirectorAndBackendpool(backendName, grpcRoute{}, r, e.Type)
		}

		switch e.Type {
		case added:
			u.lastSeenServices[key] = routings
		case deleted:
			delete(u.lastSeenServices, key)
		case modified:

		}
		return u.validatedAndReturnConfigs()
	}

	foundRoutings := struct {
		http map[string]struct{}
		grpc map[string]struct{}
	}{
		http: make(map[string]struct{}),
		grpc: make(map[string]struct{}),
	}
	for annotationKey, value := range service.Metadata.Annotations {
		var portToExpose string
		if strings.HasPrefix(annotationKey, u.httpAnnotationPrefix) {
			portToExpose = strings.TrimPrefix(annotationKey, u.httpAnnotationPrefix)
		}

		if strings.HasPrefix(annotationKey, u.grpcAnnotationPrefix) {
			portToExpose = strings.TrimPrefix(annotationKey, u.grpcAnnotationPrefix)
		}

		if portToExpose == "" {
			// Not our annotation.
			continue
		}

		// NOTE: There is no check if this port actually is exposed by service!
		backendName := fmt.Sprintf("%s_%s_%s", name, namespace, portToExpose)
		domainPort := fmt.Sprintf("%s.%s:%s", name, namespace, portToExpose)

		mainMatcher, portMatcher, err := u.annotationValueToMatchers(name, annotationKey, value)
		if err != nil {
			return nil, nil, err
		}

		if strings.HasPrefix(annotationKey, u.httpAnnotationPrefix) {
			route := httpRoute{
				hostMatcher: mainMatcher,
				portMatcher: portMatcher,
				domainPort:  domainPort,
			}
			u.applyHTTPRouteToDirectorAndBackendpool(backendName, route, httpRoute{}, e.Type)
			foundRoutings.http[backendName] = struct{}{}
			routings.http[backendName] = route
			continue
		}

		if strings.HasPrefix(annotationKey, u.grpcAnnotationPrefix) {
			route := grpcRoute{
				serviceNameMatcher: mainMatcher,
				portMatcher:        portMatcher,
				domainPort:         domainPort,
			}
			u.applygRPCRouteToDirectorAndBackendpool(backendName, route, grpcRoute{}, e.Type)
			foundRoutings.grpc[backendName] = struct{}{}
			routings.grpc[backendName] = route
			continue
		}
	}

	// What to remove?
	for backend, r := range routings.http {
		if _, ok := foundRoutings.http[backend]; ok {
			continue
		}

		// Not found, so it needs to be removed.
		u.applyHTTPRouteToDirectorAndBackendpool(backend, httpRoute{}, r, e.Type)
		delete(routings.http, backend)
	}

	for backend, r := range routings.grpc {
		if _, ok := foundRoutings.grpc[backend]; ok {
			continue
		}

		// Not found, so it needs to be removed.
		u.applygRPCRouteToDirectorAndBackendpool(backend, grpcRoute{}, r, e.Type)
		delete(routings.grpc, backend)
	}

	u.lastSeenServices[key] = routings
	return u.validatedAndReturnConfigs()
}

func (u *updater) validatedAndReturnConfigs() (*pb_config.DirectorConfig, *pb_config.BackendPoolConfig, error) {
	err := u.currentDirectorConfig.Validate()
	if err != nil {
		return nil, nil, errors.Wrap(err, "director config does not pass validation after generation.")
	}

	err = u.currentBackendConfig.Validate()
	if err != nil {
		return nil, nil, errors.Wrap(err, "backendpool config does not pass validation after generation.")
	}

	u.sortConfigs()
	return u.currentDirectorConfig, u.currentBackendConfig, nil
}

func (u *updater) annotationValueToMatchers(serviceName string, key, value string) (string, uint32, error) {
	split := strings.Split(value, ":")
	mainMatcher := split[0]
	if mainMatcher == "" {
		mainMatcher = fmt.Sprintf("%s.%s", serviceName, u.externalDomainSuffix)
	}

	portMatcher := uint32(0)
	if len(split) > 1 && split[1] != "" {
		portMatcherInt, err := strconv.Atoi(split[1])
		if err != nil {
			return "", 0, errors.Errorf("Wrong format of %s annotation value %s. In hostport, expected port to be empty or valid uint32. Got %s", key, value, split[1])
		}
		portMatcher = uint32(portMatcherInt)
	}

	return mainMatcher, portMatcher, nil
}

func (u *updater) applyHTTPRouteToDirectorAndBackendpool(backendName string, newRoute httpRoute, oldRoute httpRoute, eventType eventType) {
	if eventType == deleted || eventType == modified {
		toDeleteIndex := -1
		for i, directorRoute := range u.currentDirectorConfig.GetHttp().Routes {
			if !directorRoute.Autogenerated {
				// Do not modify not generated ones.
				continue
			}

			if directorRoute.HostMatcher == oldRoute.hostMatcher &&
				directorRoute.PortMatcher == oldRoute.portMatcher {
				toDeleteIndex = i
				break
			}
		}

		if toDeleteIndex >= 0 {
			u.currentDirectorConfig.GetHttp().Routes = append(
				u.currentDirectorConfig.GetHttp().Routes[:toDeleteIndex],
				u.currentDirectorConfig.GetHttp().Routes[toDeleteIndex+1:]...,
			)
		}

		toDeleteIndex = -1
		for i, backends := range u.currentBackendConfig.GetHttp().Backends {
			if !backends.Autogenerated {
				// Do not modify not generated ones.
				continue
			}

			if backends.Name == backendName {
				toDeleteIndex = i
				break
			}
		}

		if toDeleteIndex >= 0 {
			u.currentBackendConfig.GetHttp().Backends = append(
				u.currentBackendConfig.GetHttp().Backends[:toDeleteIndex],
				u.currentBackendConfig.GetHttp().Backends[toDeleteIndex+1:]...,
			)
		}
	}

	var empty httpRoute
	if newRoute == empty {
		return
	}

	if eventType == added || eventType == modified {
		u.currentDirectorConfig.GetHttp().Routes = append(
			u.currentDirectorConfig.GetHttp().Routes,
			&pb_httproutes.Route{
				Autogenerated: true,
				BackendName:   backendName,
				HostMatcher:   newRoute.hostMatcher,
				PortMatcher:   newRoute.portMatcher,
				ProxyMode:     pb_httproutes.ProxyMode_REVERSE_PROXY,
			},
		)

		u.currentBackendConfig.GetHttp().Backends = append(
			u.currentBackendConfig.GetHttp().Backends,
			&pb_httpbackends.Backend{
				Autogenerated: true,
				Name:          backendName,
				Resolver: &pb_httpbackends.Backend_K8S{
					K8S: &pb_resolvers.K8SResolver{
						DnsPortName: newRoute.domainPort,
					},
				},
				Balancer: pb_httpbackends.Balancer_ROUND_ROBIN,
			},
		)
	}
}

func (u *updater) applygRPCRouteToDirectorAndBackendpool(backendName string, newRoute grpcRoute, oldRoute grpcRoute, eventType eventType) {
	if eventType == deleted || eventType == modified {
		toDeleteIndex := -1
		for i, directorRoute := range u.currentDirectorConfig.GetGrpc().Routes {
			if !directorRoute.Autogenerated {
				// Do not modify not generated ones.
				continue
			}

			if directorRoute.ServiceNameMatcher == oldRoute.serviceNameMatcher &&
				directorRoute.PortMatcher == oldRoute.portMatcher {
				toDeleteIndex = i
				break
			}
		}

		if toDeleteIndex >= 0 {
			u.currentDirectorConfig.GetGrpc().Routes = append(
				u.currentDirectorConfig.GetGrpc().Routes[:toDeleteIndex],
				u.currentDirectorConfig.GetGrpc().Routes[toDeleteIndex+1:]...,
			)
		}

		toDeleteIndex = -1
		for i, backends := range u.currentBackendConfig.GetGrpc().Backends {
			if !backends.Autogenerated {
				// Do not modify not generated ones.
				continue
			}

			if backends.Name == backendName {
				toDeleteIndex = i
				break
			}
		}

		if toDeleteIndex >= 0 {
			u.currentBackendConfig.GetGrpc().Backends = append(
				u.currentBackendConfig.GetGrpc().Backends[:toDeleteIndex],
				u.currentBackendConfig.GetGrpc().Backends[toDeleteIndex+1:]...,
			)
		}
	}

	var empty grpcRoute
	if newRoute == empty {
		return
	}

	if eventType == added || eventType == modified {
		u.currentDirectorConfig.GetGrpc().Routes = append(
			u.currentDirectorConfig.GetGrpc().Routes,
			&pb_grpcroutes.Route{
				Autogenerated:      true,
				BackendName:        backendName,
				ServiceNameMatcher: newRoute.serviceNameMatcher,
				PortMatcher:        newRoute.portMatcher,
			},
		)

		u.currentBackendConfig.GetGrpc().Backends = append(
			u.currentBackendConfig.GetGrpc().Backends,
			&pb_grpcbackends.Backend{
				Autogenerated: true,
				Name:          backendName,
				Resolver: &pb_grpcbackends.Backend_K8S{
					K8S: &pb_resolvers.K8SResolver{
						DnsPortName: newRoute.domainPort,
					},
				},
				Balancer: pb_grpcbackends.Balancer_ROUND_ROBIN,
			},
		)
	}
}

func httpDirectorRouteSort(routes []*pb_httproutes.Route) {
	sort.Slice(routes, func(i int, j int) bool {
		firstRoute := routes[i]
		secondRoute := routes[j]

		if firstRoute.HostMatcher == secondRoute.HostMatcher {
			// This is critical. If they both share one host matcher and one does not have portMatcher, the latter needs to be
			// at the end.
			if firstRoute.PortMatcher == 0 {
				return false
			}

			if secondRoute.PortMatcher == 0 {
				return true
			}

			// Otherwise just sort based on port.
			return firstRoute.PortMatcher < secondRoute.PortMatcher
		}

		return strings.Compare(firstRoute.BackendName, secondRoute.BackendName) <= 0
	})
}

func grpcDirectorRouteSort(routes []*pb_grpcroutes.Route) {
	sort.Slice(routes, func(i int, j int) bool {
		firstRoute := routes[i]
		secondRoute := routes[j]

		if firstRoute.ServiceNameMatcher == secondRoute.ServiceNameMatcher {
			// This is critical. If they both share one host matcher and one does not have portMatcher, the latter needs to be
			// at the end.
			if firstRoute.PortMatcher == 0 {
				return false
			}

			if secondRoute.PortMatcher == 0 {
				return true
			}

			// Otherwise just sort based on port.
			return firstRoute.PortMatcher < secondRoute.PortMatcher
		}

		// TODO(bplotka): Add sorting based on globbing expression to not hide each one out.
		/// service_name_matcher is a globbing expression that matches a full gRPC service name.
		/// For example a method call to 'com.example.MyService/Create' would be matched by:
		///  - com.example.MyService
		///  - com.example.*
		///  - com.*
		///  - *
		/// If not present, '*' is default.
		return strings.Compare(firstRoute.BackendName, secondRoute.BackendName) <= 0
	})
}

func httpBackendpoolSort(backends []*pb_httpbackends.Backend) {
	sort.Slice(backends, func(i int, j int) bool {
		return strings.Compare(backends[i].Name, backends[j].Name) <= 0
	})
}

func grpcBackendpoolSort(backends []*pb_grpcbackends.Backend) {
	sort.Slice(backends, func(i int, j int) bool {
		return strings.Compare(backends[i].Name, backends[j].Name) <= 0
	})
}

func (u *updater) sortConfigs() {
	httpDirectorRouteSort(u.currentDirectorConfig.GetHttp().Routes)
	grpcDirectorRouteSort(u.currentDirectorConfig.GetGrpc().Routes)
	httpBackendpoolSort(u.currentBackendConfig.GetHttp().Backends)
	grpcBackendpoolSort(u.currentBackendConfig.GetGrpc().Backends)
}
